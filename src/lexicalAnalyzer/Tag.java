package lexicalAnalyzer;

public enum Tag {
	DIGIT("DIGIT"), INTEGER("INTEGER"), FLOATING_POINT("FLOATING_POINT"), CHARACTER("CHARACTER"), ID("ID"),
	REL_OP_LESS_THAN("REL_OP_LESS_THAN"), REL_OP_GREATER_THAN("REL_OP_GREATER_THAN"),
	REL_OP_LESS_THAN_OR_EQUALS_TO("REL_OP_LESS_THAN_OR_EQUALS_TO"),
	REL_OP_GREATER_THAN_OR_EQUALS_TO("REL_OP_GREATER_THAN_OR_EQUALS_TO"), REL_OP_EQUALS("REL_OP_EQUALS"),
	REL_OP_NOT_EQUAL_TO("REL_OP_NOT_EQUAL_TO"), ARI_OP_ADDITION("ARI_OP_ADDITION"), ARI_OP_SUBTRACTION("ARI_OP_SUBTRACTION"),
	ARI_OP_MULTIPLICATION("ARI_OP_MULTIPLICATION"), ARI_OP_DIVISION("ARI_OP_DIVISION"),
	ARI_OP_ATTRIBUTION("ARI_OP_ATTRIBUTION"), SP_CHAR_OPEN_PARENTHESES("SP_CHAR_OPEN_PARENTHESES"),
	SP_CHAR_CLOSE_PARENTHESES("SP_CHAR_CLOSE_PARENTHESES"), SP_CHAR_OPEN_BRACES("SP_CHAR_OPEN_BRACES"),
	SP_CHAR_CLOSE_BRACES("SP_CHAR_CLOSE_BRACES"), SP_CHAR_COMMA("SP_CHAR_OPEN_COMMA"),
	SP_CHAR_SEMICOLON("SP_CHAR_CLOSE_SEMICOLON"), MAIN("MAIN"), IF("IF"), ELSE("ELSE"), WHILE("WHILE"), DO("DO"),
	FOR("FOR"), INT("INT"), FLOAT("FLOAT"), CHAR("CHAR"), OP_COND_NOT("NOT"), EOF("EOF"), RETURN("RETURN");

	private final String description;

	Tag(String desc) {
		this.description = desc;
	}

	public String getDescription() {
		return this.description;
	}
}
